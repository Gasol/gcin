--- a/eggtrayicon.cpp
+++ b/eggtrayicon.cpp
@@ -352,7 +352,7 @@
 
       gdk_window_add_filter (gdkwin, egg_tray_icon_manager_filter, icon);
 
-      if (dock_if_realized && GTK_WIDGET_REALIZED (icon))
+      if (dock_if_realized && gtk_widget_get_realized (icon))
 	egg_tray_icon_send_dock_request (icon);
 
       egg_tray_icon_get_orientation_property (icon);
@@ -398,7 +398,7 @@
 static void
 make_transparent (GtkWidget *widget, gpointer user_data)
 {
-	if (GTK_WIDGET_NO_WINDOW (widget) || GTK_WIDGET_APP_PAINTABLE (widget))
+	if (!gtk_widget_get_has_window (widget) || gtk_widget_get_app_paintable (widget))
 		return;
 
 	gtk_widget_set_app_paintable (widget, TRUE);
--- a/anthy.cpp
+++ b/anthy.cpp
@@ -993,7 +993,7 @@
 
 int anthy_visible()
 {
-  return GTK_WIDGET_VISIBLE(win_anthy);
+  return gtk_widget_get_visible(win_anthy);
 }
 
 extern gboolean force_show;
--- a/eve.cpp
+++ b/eve.cpp
@@ -661,10 +661,10 @@
     return FALSE;
   switch (current_CS->in_method) {
     case 3:
-      return gwin_pho && GTK_WIDGET_VISIBLE(gwin_pho);
+      return gwin_pho && gtk_widget_get_visible(gwin_pho);
 #if USE_TSIN
     case 6:
-      return gwin0 && GTK_WIDGET_VISIBLE(gwin0);
+      return gwin0 && gtk_widget_get_visible(gwin0);
 #endif
     case 10:
       break;
@@ -675,7 +675,7 @@
     default:
       if (!gwin_gtab)
         return FALSE;
-      return gwin_gtab && GTK_WIDGET_VISIBLE(gwin_gtab);
+      return gwin_gtab && gtk_widget_get_visible(gwin_gtab);
   }
 
   return FALSE;
--- a/gtab.cpp
+++ b/gtab.cpp
@@ -1230,7 +1230,7 @@
     return feedkey_pho(key, 0);
 
   if (same_pho_query_state == SAME_PHO_QUERY_none && gwin_pho &&
-    GTK_WIDGET_VISIBLE(gwin_pho))
+    gtk_widget_get_visible(gwin_pho))
      hide_win_pho();
 
 
--- a/win-gtab.cpp
+++ b/win-gtab.cpp
@@ -526,7 +526,7 @@
 
 //  dbg("show_win_gtab()\n");
 #if UNIX
-  if (!GTK_WIDGET_VISIBLE(gwin_gtab))
+  if (!gtk_widget_get_visible(gwin_gtab))
 #endif
     gtk_widget_show(gwin_gtab);
 
--- a/win0.cpp
+++ b/win0.cpp
@@ -215,7 +215,7 @@
 void disp_pho_sub(GtkWidget *label, int index, char *pho);
 void disp_tsin_pho(int index, char *pho)
 {
-  if (button_pho && !GTK_WIDGET_VISIBLE(button_pho))
+  if (button_pho && !gtk_widget_get_visible(button_pho))
     gtk_widget_show(button_pho);
 
   disp_pho_sub(label_pho, index, pho);
@@ -270,7 +270,7 @@
 #if 0
   GtkWidget *widget =chars[index].line;
 
-  if (!GTK_WIDGET_VISIBLE(widget)) {
+  if (!gtk_widget_get_visible(widget)) {
     widget = chars[index].vbox;
   }
 #endif
@@ -603,7 +603,7 @@
   if (gcin_pop_up_win && !tsin_has_input() && !force_show)
     return;
 #if UNIX
-  if (!GTK_WIDGET_VISIBLE(gwin0))
+  if (!gtk_widget_get_visible(gwin0))
 #endif
   {
     gtk_widget_show(gwin0);
--- a/win1.cpp
+++ b/win1.cpp
@@ -166,7 +166,7 @@
 
 void disp_selections(int x, int y)
 {
-  if (!GTK_WIDGET_VISIBLE(gwin1)) {
+  if (!gtk_widget_get_visible(gwin1)) {
     gtk_widget_show(gwin1);
   }
 
@@ -186,7 +186,7 @@
 
 void raise_tsin_selection_win()
 {
-  if (gwin1 && GTK_WIDGET_VISIBLE(gwin1))
+  if (gwin1 && gtk_widget_get_visible(gwin1))
     gtk_window_present(GTK_WINDOW(gwin1));
 }
 
--- a/tray.cpp
+++ b/tray.cpp
@@ -286,7 +286,7 @@
   gtk_widget_show_all (GTK_WIDGET (tray_icon));
   tray_da_win = da->window;
   // tray window is not ready ??
-  if (!tray_da_win || !GTK_WIDGET_DRAWABLE(da)) {
+  if (!tray_da_win || !gtk_widget_is_drawable(da)) {
     gtk_widget_destroy(GTK_WIDGET(tray_icon));
     da = NULL;
     return FALSE;
